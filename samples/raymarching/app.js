require(["Core/Engine","Core/Node","Components/Camera","Components/CameraController","Passes/RenderPass","Passes/UpdatePass","Renderer/BackBufferTarget","Utils/MeshHelper"],function(e,o,i,t,a,n,r,s){"use strict";function c(e,o,i){var t=e.resourceManager.createShader({vs:["precision highp float;","attribute vec3 aPosition;","varying vec2 vPosition;","void main()","{","	gl_Position = vec4(aPosition, 1);","	vPosition = aPosition.xy;","}"],fs:["precision highp float;","varying vec2 vPosition;","uniform vec3 uPosition;","uniform mat4 uInverseViewProjection;","uniform float uTime;","uniform float uNear;","uniform float uFar;","uniform float uPrecision;","uniform float uSharpness;","uniform float uVisualization;","uniform float uAOSize;","const vec3 lightDirection = normalize(vec3(0.5, -1.0, -0.8));","mat3 cubeRotation = mat3(","	vec3(cos(uTime), 0.0, -sin(uTime)),","	vec3(0.0, 1.0, 0.0),","	vec3(sin(uTime), 0.0, cos(uTime))",");","float Union(float d1, float d2)","{","	return min(d1, d2);","}","float Merge(float d1, float d2)","{","	const float k = 0.5;","	float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);","	return mix(d2, d1, h) - k * h * (1.0 - h);","}","float Plane(vec3 position)","{","	return position.y;","}","float Sphere(vec3 position, float radius, vec3 center)","{","	return length(position - center) - radius;","}","float Cube(vec3 position, vec3 size, float radius)","{","	return length(max(abs(position) - (size - radius), 0.0)) - radius;","}","float RotatedCube(vec3 position, vec3 size, float radius)","{","	vec3 tPosition = cubeRotation * position;","	return Cube(tPosition, size, radius);","}","float Scene(vec3 position)","{","	float result = Sphere(position, 1.0, vec3(0.0, 2.0 + cos(uTime) * 0.5, 0.0));","	result = Merge(result, RotatedCube(position, vec3(1.0, 0.5, 1.0), 0.05));","	result = Union(result, Plane(position));","	return result;","}","vec3 GetNormal(vec3 position)","{","	return normalize(vec3(","		Scene(position + vec3(0.0001, 0.0, 0.0)) - Scene(position - vec3(0.0001, 0.0, 0.0)),","		Scene(position + vec3(0.0, 0.0001, 0.0)) - Scene(position - vec3(0.0, 0.0001, 0.0)),","		Scene(position + vec3(0.0, 0.0, 0.0001)) - Scene(position - vec3(0.0, 0.0, 0.0001))","	));","}","float GetShadow(vec3 position)","{","	float shadow = 1.0;","	float t = uNear;","	for (int i = 0; i < "+i.shadowIterations+"; ++i)","	{","		float distance = Scene(position - lightDirection * t);","		if (distance < uPrecision)","		{","			shadow = 0.0;","			break;","		}","		shadow = min(shadow, uSharpness * distance / t);","		t += distance;","	}","	return shadow;","}","float GetAO(vec3 position, vec3 normal)","{","	float ao = 0.0;","	const float aoIteration = float("+i.aoIterations+");","	for (int i = 0; i < "+i.aoIterations+"; ++i)","	{","		float t = 0.01 + uAOSize * float(i) / (aoIteration - 1.0);","		float distance = Scene(position + normal * t);","		ao += (t - distance) * (aoIteration - float(i)) / aoIteration;","	}","	return clamp(1.0 - ao, 0.0, 1.0);","}","float Trace(vec3 position, vec3 direction)","{","	float t = uNear;","	float index = 0.0;","	for (int i = 0; i < "+i.iterations+"; ++i)","	{","		float result = Scene(position + direction * t);","		if (result < uPrecision || t > uFar) { break; }","		t += result;","		index += 1.0;","	}","	return uVisualization == 0.0 ? t : index;","}","vec3 HueToRGB(float hue)","{","	float red = abs(hue * 6.0 - 3.0) - 1.0;","	float green = 2.0 - abs(hue * 6.0 - 2.0);","	float blue = 2.0 - abs(hue * 6.0 - 4.0);","	return clamp(vec3(red, green, blue), vec3(0.0), vec3(1.0));","}","void main()","{","	vec4 position = uInverseViewProjection * vec4(vPosition, -1.0, 1.0);","	position.xyz /= position.w;","	vec3 direction = normalize(position.xyz - uPosition);","	float distance = Trace(position.xyz, direction);","	if (uVisualization == 0.0)","	{","		if (distance > uFar)","		{","			gl_FragColor = vec4(0.1, 0.1, 0.1, 1.0);","		}","		else","		{","			vec3 point = position.xyz + distance * direction;","			vec3 normal = GetNormal(point);","			float diffuse = max(0.0, dot(normal, -lightDirection));","			diffuse *= max(GetShadow(point), 0.1);","			diffuse = max(diffuse, 0.1);","			diffuse *= GetAO(point, normal);","			gl_FragColor = vec4(vec3(pow(diffuse, 0.45)), 1.0);","		}","	}","	else if (uVisualization == 1.0)","	{","		distance = distance / float("+i.iterations+" - 1);","		gl_FragColor = vec4(HueToRGB((1.0 - distance) * 0.6666), 1.0);","	}","}"],attributes:[{semantic:"position",name:"aPosition"}],uniforms:[{name:"uPosition",reference:"cameraPosition"},{name:"uInverseViewProjection",reference:"inverseViewProjection"},{name:"uTime",reference:"time"},{name:"uNear",reference:"cameraNear"},{name:"uFar",reference:"cameraFar"},{name:"uPrecision",type:"float",object:i,attribute:"precision"},{name:"uSharpness",type:"float",object:i,attribute:"shadowSharpness"},{name:"uVisualization",type:"float",object:i,attribute:"visualization"},{name:"uAOSize",type:"float",object:i,attribute:"aoSize"}]});o.setShader(t),t.release()}var u=document.getElementById("gui"),l=new dat.GUI({width:u.clientWidth,autoPlace:!1}),d=new e(document.getElementById("webgl2")),f=s.createFullscreenQuad(d),p=new o(d,"quad"),m=new o(d,"camera"),v={precision:.002,iterations:70,shadowIterations:20,shadowSharpness:4,aoIterations:5,aoSize:.5,visualization:0};c(d,f,v),m.addComponent(new i(d,{near:.1,far:20})),m.addComponent(new t(d,{position:[1.5,2,8],target:[0,1.5,0]})),d.sceneGraph.addChild(m),d.passes.push(new a(d,{renderTarget:new r(d),camera:m.getComponent("Camera")})),p.addComponent(f),d.sceneGraph.addChild(p),d.passes.push(new n(d)),u.appendChild(l.domElement),l.add(m.getComponent(i.type),"near"),l.add(m.getComponent(i.type),"far"),l.add(v,"precision"),l.add(v,"iterations").onChange(function(){c(d,f,v)}),l.add(v,"shadowIterations").onChange(function(){c(d,f,v)}),l.add(v,"shadowSharpness"),l.add(v,"aoIterations").onChange(function(){c(d,f,v)}),l.add(v,"aoSize"),l.add(v,"visualization",{"default":0,iterations:1}),d.start()});