require(["Core/Engine","Core/Node","Components/Camera","Components/CameraController","Passes/RenderPass","Passes/UpdatePass","Renderer/BackBufferTarget","Utils/MeshHelper"],function(e,i,o,n,t,r,a,s){"use strict";function c(e,i,o){var n=e.resourceManager.createShader({vs:["precision highp float;","attribute vec3 aPosition;","varying vec2 vPosition;","void main()","{","	gl_Position = vec4(aPosition, 1);","	vPosition = aPosition.xy;","}"],fs:["precision highp float;","varying vec2 vPosition;","uniform vec3 uPosition;","uniform mat4 uInverseViewProjection;","uniform float uTime;","uniform float uNear;","uniform float uFar;","uniform float uPrecision;","const vec3 lightDirection = normalize(vec3(0.5, -1.0, -0.8));","mat3 cubeRotation = mat3(","	vec3(cos(uTime), 0.0, -sin(uTime)),","	vec3(0.0, 1.0, 0.0),","	vec3(sin(uTime), 0.0, cos(uTime))",");","float Union(float d1, float d2)","{","	return d1 < d2 ? d1 : d2;","}","float Plane(vec3 position)","{","	return position.y;","}","float Sphere(vec3 position, float radius, vec3 center)","{","	return length(position - center) - radius;","}","float Cube(vec3 position, vec3 size)","{","	return length(max(abs(position) - size, 0.0));","}","float RotatedCube(vec3 position, vec3 size)","{","	vec3 tPosition = cubeRotation * position;","	return Cube(tPosition, size);","}","float Scene(vec3 position)","{","	float result = Sphere(position, 1.0, vec3(0.0, 1.5, 0.0));","	result = Union(result, RotatedCube(position, vec3(1.0, 0.5, 1.0)));","	result = Union(result, Plane(position));","	return result;","}","vec3 GetNormal(vec3 position)","{","	return normalize(vec3(","		Scene(position + vec3(0.0001, 0.0, 0.0)) - Scene(position - vec3(0.0001, 0.0, 0.0)),","		Scene(position + vec3(0.0, 0.0001, 0.0)) - Scene(position - vec3(0.0, 0.0001, 0.0)),","		Scene(position + vec3(0.0, 0.0, 0.0001)) - Scene(position - vec3(0.0, 0.0, 0.0001))","	));","}","float Trace(vec3 position, vec3 direction)","{","	float t = uNear;","	for (int i = 0; i < "+o.iterations+"; ++i) {","		vec3 point = position + direction * t;","		float result = Scene(point);","		if (result < uPrecision || t > uFar) { break; }","		t += result;","	}","	return t;","}","void main()","{","	vec4 position = uInverseViewProjection * vec4(vPosition, -1.0, 1.0);","	position.xyz /= position.w;","	vec3 direction = normalize(position.xyz - uPosition);","	float distance = Trace(position.xyz, direction);","	if (distance > uFar)","	{","		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);","	}","	else","	{","		vec3 normal = GetNormal(position.xyz + distance * direction);","		float diffuse = max(0.1, dot(normal, -lightDirection));","		gl_FragColor = vec4(vec3(pow(diffuse, 0.45)), 1.0);","	}","}"],attributes:[{semantic:"position",name:"aPosition"}],uniforms:[{name:"uPosition",reference:"cameraPosition"},{name:"uInverseViewProjection",reference:"inverseViewProjection"},{name:"uTime",reference:"time"},{name:"uNear",reference:"cameraNear"},{name:"uFar",reference:"cameraFar"},{name:"uPrecision",type:"float",object:o,attribute:"precision"}]});i.setShader(n),n.release()}var u=document.getElementById("gui"),l=new dat.GUI({width:u.clientWidth,autoPlace:!1}),d=new e(document.getElementById("webgl2"),{antialias:!0}),p=s.createFullscreenQuad(d),m=new i(d,"quad"),v=new i(d,"camera"),f={precision:.002,iterations:50};c(d,p,f),v.addComponent(new o(d,{far:20})),v.addComponent(new n(d,{position:[1.5,2,8],target:[0,1,0]})),d.sceneGraph.addChild(v),d.passes.push(new t(d,{renderTarget:new a(d),camera:v.getComponent("Camera")})),m.addComponent(p),d.sceneGraph.addChild(m),d.passes.push(new r(d)),u.appendChild(l.domElement),l.add(v.getComponent(o.type),"near"),l.add(v.getComponent(o.type),"far"),l.add(f,"precision"),l.add(f,"iterations").onChange(function(){c(d,p,f)}),d.start()});