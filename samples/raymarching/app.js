require(["Core/Engine","Core/Node","Components/Camera","Components/CameraController","Passes/RenderPass","Passes/UpdatePass","Renderer/BackBufferTarget","Utils/MeshHelper"],function(e,i,o,t,n,a,r,s){"use strict";function c(e,i,o){var t=e.resourceManager.createShader({vs:["precision highp float;","attribute vec3 aPosition;","varying vec2 vPosition;","void main()","{","	gl_Position = vec4(aPosition, 1);","	vPosition = aPosition.xy;","}"],fs:["precision highp float;","varying vec2 vPosition;","uniform vec3 uPosition;","uniform mat4 uInverseViewProjection;","uniform float uTime;","uniform float uNear;","uniform float uFar;","uniform float uPrecision;","uniform float uSharpness;","uniform float uVisualization;","const vec3 lightDirection = normalize(vec3(0.5, -1.0, -0.8));","mat3 cubeRotation = mat3(","	vec3(cos(uTime), 0.0, -sin(uTime)),","	vec3(0.0, 1.0, 0.0),","	vec3(sin(uTime), 0.0, cos(uTime))",");","float Union(float d1, float d2)","{","	return d1 < d2 ? d1 : d2;","}","float Plane(vec3 position)","{","	return position.y;","}","float Sphere(vec3 position, float radius, vec3 center)","{","	return length(position - center) - radius;","}","float Cube(vec3 position, vec3 size, float radius)","{","	return length(max(abs(position) - (size - radius), 0.0)) - radius;","}","float RotatedCube(vec3 position, vec3 size, float radius)","{","	vec3 tPosition = cubeRotation * position;","	return Cube(tPosition, size, radius);","}","float Scene(vec3 position)","{","	float result = Sphere(position, 1.0, vec3(0.0, 1.5, 0.0));","	result = Union(result, RotatedCube(position, vec3(1.0, 0.5, 1.0), 0.05));","	result = Union(result, Plane(position));","	return result;","}","vec3 GetNormal(vec3 position)","{","	return normalize(vec3(","		Scene(position + vec3(0.0001, 0.0, 0.0)) - Scene(position - vec3(0.0001, 0.0, 0.0)),","		Scene(position + vec3(0.0, 0.0001, 0.0)) - Scene(position - vec3(0.0, 0.0001, 0.0)),","		Scene(position + vec3(0.0, 0.0, 0.0001)) - Scene(position - vec3(0.0, 0.0, 0.0001))","	));","}","float GetShadow(vec3 position)","{","	float shadow = 1.0;","	float t = uNear;","	for (int i = 0; i < "+o.shadowIterations+"; ++i)","	{","		float distance = Scene(position - lightDirection * t);","		if (distance < uPrecision)","		{","			shadow = 0.0;","			break;","		}","		shadow = min(shadow, uSharpness * distance / t);","		t += distance;","	}","	return shadow;","}","float Trace(vec3 position, vec3 direction)","{","	float t = uNear;","	float index = 0.0;","	for (int i = 0; i < "+o.iterations+"; ++i)","	{","		float result = Scene(position + direction * t);","		if (result < uPrecision || t > uFar) { break; }","		t += result;","		index += 1.0;","	}","	return uVisualization == 0.0 ? t : index;","}","vec3 HueToRGB(float hue)","{","	float red = abs(hue * 6.0 - 3.0) - 1.0;","	float green = 2.0 - abs(hue * 6.0 - 2.0);","	float blue = 2.0 - abs(hue * 6.0 - 4.0);","	return clamp(vec3(red, green, blue), vec3(0.0), vec3(1.0));","}","void main()","{","	vec4 position = uInverseViewProjection * vec4(vPosition, -1.0, 1.0);","	position.xyz /= position.w;","	vec3 direction = normalize(position.xyz - uPosition);","	float distance = Trace(position.xyz, direction);","	if (uVisualization == 0.0)","	{","		if (distance > uFar)","		{","			gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);","		}","		else","		{","			vec3 point = position.xyz + distance * direction;","			vec3 normal = GetNormal(point);","			float diffuse = max(0.0, dot(normal, -lightDirection));","			diffuse *= max(GetShadow(point), 0.1);","			gl_FragColor = vec4(vec3(pow(max(diffuse, 0.1), 0.45)), 1.0);","		}","	}","	else if (uVisualization == 1.0)","	{","		distance = distance / float("+o.iterations+" - 1);","		gl_FragColor = vec4(HueToRGB((1.0 - distance) * 0.6666), 1.0);","	}","}"],attributes:[{semantic:"position",name:"aPosition"}],uniforms:[{name:"uPosition",reference:"cameraPosition"},{name:"uInverseViewProjection",reference:"inverseViewProjection"},{name:"uTime",reference:"time"},{name:"uNear",reference:"cameraNear"},{name:"uFar",reference:"cameraFar"},{name:"uPrecision",type:"float",object:o,attribute:"precision"},{name:"uSharpness",type:"float",object:o,attribute:"shadowSharpness"},{name:"uVisualization",type:"float",object:o,attribute:"visualization"}]});i.setShader(t),t.release()}var u=document.getElementById("gui"),d=new dat.GUI({width:u.clientWidth,autoPlace:!1}),l=new e(document.getElementById("webgl2"),{antialias:!0}),f=s.createFullscreenQuad(l),p=new i(l,"quad"),m=new i(l,"camera"),v={precision:.002,iterations:50,shadowIterations:20,shadowSharpness:4,visualization:0};c(l,f,v),m.addComponent(new o(l,{near:.1,far:20})),m.addComponent(new t(l,{position:[1.5,2,8],target:[0,1,0]})),l.sceneGraph.addChild(m),l.passes.push(new n(l,{renderTarget:new r(l),camera:m.getComponent("Camera")})),p.addComponent(f),l.sceneGraph.addChild(p),l.passes.push(new a(l)),u.appendChild(d.domElement),d.add(m.getComponent(o.type),"near"),d.add(m.getComponent(o.type),"far"),d.add(v,"precision"),d.add(v,"iterations").onChange(function(){c(l,f,v)}),d.add(v,"shadowIterations").onChange(function(){c(l,f,v)}),d.add(v,"shadowSharpness"),d.add(v,"visualization",{"default":0,iterations:1}),l.start()});